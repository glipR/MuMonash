# TLE on python, should be fine in cpp

# We need to figure out at which point the circles generated by people standing:
# 1. Does not intersect the start end end points
# 2. Does not form a line from left or bottom to right or top.

# So binary search on the 'social distance', and then bfs.
def sq_dist(p1, p2):
    return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1])

x, y = list(map(int, input().split()))
n = int(input())
positions = [list(map(float, input().split())) for _ in range(n)]

lo = 0
hi = 2*x + 2*y + 1

while hi - lo >= 1e-5 / 2:
    mid = (hi + lo) / 2
    mid_sq = mid * mid
    # Can we get across when rule is mid?
    for a, b in positions:
        if sq_dist((a, b), (0, 0)) <= mid_sq:
            hi = mid
            continue
        if sq_dist((a, b), (x, y)) <= mid_sq:
            hi = mid
            continue
    # Start and end positions are safe.
    # left, right, up, down
    adj = [[] for _ in range(n)] + [[], [], [], []]
    for i in range(len(positions)):
        p1 = positions[i]
        if p1[0] <= mid:
            adj[n].append(i)
            adj[i].append(n)
        if x - p1[0] <= mid:
            adj[n+1].append(i)
            adj[i].append(n+1)
        if p1[1] <= mid:
            adj[n+2].append(i)
            adj[i].append(n+2)
        if y - p1[1] <= mid:
            adj[n+3].append(i)
            adj[i].append(n+3)
        for j in range(i+1, len(positions)):
            p2 = positions[j]
            # The circles intersect if double mid is the distance.
            if sq_dist(p1, p2) <= 4 * mid_sq:
                adj[i].append(j)
                adj[j].append(i)
    # Search from left and down to up and right?
    found = [False]*(n+4)
    looking = [n, n+3]
    while looking:
        l = looking.pop()
        found[l] = True
        for child in adj[l]:
            if found[child]: continue
            looking.append(child)
    if found[n+1] or found[n+2]:
        hi = mid
    else:
        lo = mid

print(lo)
